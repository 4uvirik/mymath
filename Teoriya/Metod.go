package main

import "fmt"

func main() {
	definition()
}

// Метод — это функция, которая «прилипает» к структуре.
//То есть, если у тебя есть структура (например, Person), ты можешь дать ей поведение, добавив метод.
// получатель (receiver), он указывает, к какому типу относится метод
// Есть два рессивера:
//1 - value рессивер - указывается просто тип
//2 - pointer рессивер - указывается указатель на тип

type Square struct {
	Side int
}

// У нас есть структура квадрат с одним полем "сторона"

func (s Square) Perimeter() {
	fmt.Printf("%T, %#v \n", s, s)
	fmt.Printf("Периметр квадрата: %d \n", s.Side*4)
}

// Применяем метод Perimeter к типу Square через переменную s которая доступна внутри данного метода
//(считаем периметр умножая сторону на 4)

func (s *Square) Scale(multiplier int) {
	fmt.Printf("%T, %#v \n", s, s)
	s.Side *= multiplier
	fmt.Printf("%T, %#v \n", s, s)
}

// Применяем метод Scale применяющий интовый параметр multiplier к указателю типа Square через переменную s
//(считаем площадь)

func definition() {
	square := Square{Side: 4} // Задаем переменную которая является структурой с полем сторона 4
	pSquare := &square        // Задаем указатель на эту переменную (понадобется для метода Scale)

	square2 := Square{Side: 2} // Задаем вторую переменную которая является структурой с полем сторона 2

	square.Perimeter()  // Вызываем метод Perimeter у квадрата со стороной 4
	square2.Perimeter() // Вызываем метод Perimeter у квадрата со стороной 2

	pSquare.Scale(2) // Вызываем метод Scale у указателя квадрата передавая длину стороны 2

	// Есть синтаксический сахар позволяющий вызывать метод с value рессивером у указателя
	// или наоборот вызвать метод с pointer рессивера у обычного значения

	pSquare.Perimeter() // Golang сам разимяновывает указатель и затем уже обычное значение передает в функцию периметр
	square.Scale(3)     // Gplang берет значение, получает на него указатель и по указателю вызывает метод

}
